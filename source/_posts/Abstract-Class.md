---
title: Abstract Class
description: 抽象类
comments: false
hidden: false
top: false
date: 2020-08-24 13:44:14
categories:
tags:
---

<img src="https://cdn.journaldev.com/wp-content/uploads/2013/07/abstract-class-in-java.jpg" width="100%"/>

<!-- more -->

## 定义

使用 `abstract` 关键字修饰的方法称之为**抽象方法**，使用 `abstract` 关键字修饰的类称之为**抽象类**。

## 作用

1. 单独定义方法签名
2. 强制子类重写方法
3. 限制创建实例

## 特点

1. 抽象类无法实例化

   因为抽象方法本身是无法执行的，所以，抽象类类也无法被实例化。

   无法实例化的抽象类有什么用？

   因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法。因此，抽象方法实际上相当于定义了“规范”。

2. 不能使用 `private` 修饰抽象方法

   抽象方法必须对子类可见，而 private 修饰的方法对子类不可见，因此不能使用 private 修饰符。

   如果不带修饰符，那么就是包内访问。这种情况下，不一定能保证对子类可见。如果子类和父类不在一个包下面，子类是无法访问（无法覆盖）父类的方法。因此，抽象方法的访问权限不应该是包内访问。可以使用 public 和 protected，大多数情况下都是使用 public。

## 抽象类与接口的区别

### 语法层面

1. 抽象类可以有构造方法，接口中不能有构造方法。
2. 抽象类可以拥有任意范围的成员数据，接口仅能够有常量。
3. 可以拥有非抽象方法，但是接口所有的方法都必须是抽象方法(1.8 增加了默认方法和静态方法)。
4. 抽象类中抽象方法的访问类型除了 private 以外都可以，但接口中的抽象方法只能是 public 类型，并且默认即为public abstract类型。
5. 抽象类中可以包含静态方法，接口中不能包含静态方法(1.8 之后可以)
6. 一个类可以实现多个接口，但只能继承一个抽象类。

### 设计层面

1、抽象对象不同

抽象类是对类抽象，而接口是对行为的抽象。

抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

2、父子关系不同

抽象类与子类之间是“is-a”的关系（ArrayList is a AbstractList），接口与实现类之间则不一定是“is-a“的关系，还可以是“could-be”的关系（XXX could be Serializable）

我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说**抽象类所体现的是一种继承关系**，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。

3、开发模式不同

抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们再抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

## 抽象类实际应用

[模版方法模式](http://libo9527.github.io/2020/08/26/Design-Pattern-Template-Method/)

> 模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。——《Head First 设计模式（中文版）》

