---
title: In-depth understanding of the Java Virtual Machine -- 3rd edition
description: 深入理解Java虚拟机（第3版）
date: 2020-07-16 17:53:45
categories:
tags:
---

<img src="https://img30.360buyimg.com/vc/jfs/t1/99692/8/6999/163928/5df8449fE81a77bbc/55441b8d8f41b6b3.jpg" width="100%"/>

<!-- more -->

>[深入理解Java虚拟机（第3版） - 图书- 豆瓣](https://m.douban.com/book/subject/34907497/)

# 第一部分　走近Java

## 第1章　走近Java

{% cq %}世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程{% endcq %}

### 1.1　概述

Java 的优点：

- 结构严谨

  因为 Java 只支持**面向对象**这一种[编程范式](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B)

- 面向对象

  在面向对象编程中，程序员认为程序**是**一系列相互作用的对象

- 摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想

- 提供了一种相对安全的**内存管理和访问**机制，避免了绝大部分内存泄漏和指针越界问题

- 实现了热点代码检测和运行时编译及优化，使得应用能随着运行时间的增长而获得更高的性能

- 有一套完善的应用程序**接口**，还有无数来自商业机构和开源社区的**第三方类库**来帮助用户实现各种各样的功能

### 1.2　Java技术体系

![](/post_image/Java-Technology-System.png)

#### 根据 Java 各个组成部分的功能来进行划分

从传统意义上来看，[JCP](https://zh.wikipedia.org/zh-hans/JCP) 官方所定义的 Java 技术体系包括了以下几个组成部分： 

- Java 程序设计语言
- 各种硬件平台上的 Java 虚拟机实现
- Class 文件格式
- Java 类库 API
- 来自商业机构和开源社区的第三方 Java 类库

Java 程序设计语言、Java 虚拟机、Java 类库这**三部分**统称为 **JDK**(Java Development Kit)，JDK 是用于支持 Java 程序**开发**的最小环境。

可以把 Java 类库 API 中的 Java SE API 子集和 Java 虚拟机这**两部分**统称为 **JRE**(Java Runtime Environment)，JRE 是支持 Java 程序**运行**的标准环境。

![](https://wiki.jikexueyuan.com/project/java-vm/images/jvmstructure.gif)

#### 按照技术所服务的领域来或者技术关注的重点业务来划分

1. Java Card：

   支持 Java 小程序(Applets)运行在小内存设备(如智能卡)上的平台。 

2. Java ME(Micro Edition)：

   支持 Java 程序运行在移动终端(手机、PDA)上的平台，对 Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在 JDK 6 以前被称为J2ME。

   有一点读者请勿混淆，现在在智能手机上非常流行的、主要使用 Java 语言开发程序的 **Android 并不属于 Java ME**。 

3. Java SE(Standard Edition)：

   支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的 Java 核心 API，这条产品线在 JDK 6 以前被称为 J2SE。 

4. Java EE(Enterprise Edition)：

   支持使用多层架构的企业应用(如ERP、MIS、CRM应用)的 Java平台，除了提供 Java SE API 外，还对其做了大量有针对性的扩充，并提供了相关的部署支持，这条产品线在 JDK 6 以前被称为J2EE，在 JDK 10 以后被 Oracle 放弃，捐献给Eclipse基金会管理，此后被称为 Jakarta EE。

### 1.3　Java发展史

![](/post_image/java-time-line.png)

<iframe src='https://cdn.knightlab.com/libs/timeline3/latest/embed/index.html?source=1UvTGFxDU7TIq41bT_uZrUNvomG7mAXxAF_bUdeWzkZw&font=Default&lang=en&initial_zoom=2&height=650' width='100%' height='650' webkitallowfullscreen mozallowfullscreen allowfullscreen frameborder='0'></iframe>

1991年4月，由 James Gosling 博士领导的绿色计划（Green Project）开始启动，这个计划的产品就是Java语言的前身：Oak（得名于James Gosling办公室外的一棵橡树）。

1995年5月23日，Oak语言改名为 Java，并且在 SunWorld 大会上正式发布 Java 1.0 版本。Java 语言第一次提出了 “Write Once，Run Anywhere” 的口号。

1996年1月23日，JDK 1.0发布，Java语言有了第一个正式版本的运行环境。JDK 1.0提供了一个纯解释执行的Java虚拟机实现（Sun Classic VM）。JDK 1.0版本的代表技术包括：Java虚拟机、Applet、 AWT等。 

1996年4月，十个最主要的操作系统和计算机供应商声明将在其产品中嵌入Java技术。同年9月， 已有大约8.3万个网页应用了Java技术来制作。

在1996年5月底，Sun于美国旧金山举行了首届JavaOne大会，从此JavaOne成为全世界数百万Java语言开发者每年一度的技术盛会。

1997年2月19日，Sun公司发布了JDK 1.1，Java里许多最基础的技术支撑点（如JDBC等）都是在 JDK 1.1版本中提出的，JDK 1.1版的技术代表有：JAR文件格式、JDBC、JavaBeans、RMI等。Java语言的语法也有了一定的增强，如内部类（Inner Class）和反射（Reflection）都是在这时候出现的。 直到1999年4月8日，JDK 1.1一共发布了1.1.0至1.1.8这9个版本。从1.1.4以后，每个JDK版本都有一个属于自己的名字（工程代号），分别为：JDK 1.1.4-Sparkler（宝石）、JDK 1.1.5-Pumpkin（南瓜）、JDK 1.1.6-Abigail（阿比盖尔，女子名）、JDK 1.1.7-Brutus（布鲁图，古罗马政治家和将军）和JDK 1.1.8-Chelsea（切尔西，城市名）。 

1998年12月4日，JDK迎来了一个里程碑式的重要版本：工程代号为Playground（竞技场）的JDK 1.2，Sun在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。在这个版本中出现的代表性技术非常多，如EJB、Java Plug-in、Java IDL、Swing等，并且这个版本中Java虚拟机第一次内置了JIT（Just In Time）即时编译器（JDK 1.2中曾并存过三个虚拟机，Classic VM、HotSpot VM和Exact VM，其中 Exact VM只在Solaris平台出现过；后面两款虚拟机都是内置了JIT即时编译器的，而之前版本所带的 Classic VM只能以外挂的形式使用即时编译器）。在语言和API层面上，Java添加了strictfp关键字， Java类库添加了现在Java编码之中极为常用的一系列Collections集合类等。

在1999年3月和7月，分别有 JDK 1.2.1和JDK 1.2.2两个小升级版本发布。 

1999年4月27日，HotSpot虚拟机诞生。HotSpot最初由一家名为“Longview Techno-logies”的小公司开发，由于HotSpot的优异表现，这家公司在1997年被Sun公司收购。Hot-Spot虚拟机刚发布时是作为 JDK 1.2的附加程序提供的，后来它成为JDK 1.3及之后所有JDK版本的默认Java虚拟机。

2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布。相对于JDK 1.2，JDK 1.3的改进主要体现在Java类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始被作为一项平台级服务提供（以前JNDI仅仅是一项扩展服务），使用CORBA IIOP来实现RMI的通信协议，等等。这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且新添加了JavaSound类库。

JDK 1.3有1个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），于2001年5月17日发布。 自从JDK 1.3开始，Sun公司维持着稳定的研发节奏：大约每隔两年发布一个JDK的主版本，以动 物命名，期间发布的各个修正版本则以昆虫作为工程代号。 

2002年2月13日，JDK 1.4发布，工程代号为Merlin（灰背隼）。JDK 1.4是标志着Java真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM等著名公司都有参与功能规划，甚至实现自己独立发行的JDK 1.4。哪怕是在近二十年后的今天，仍然有一些主流应用能直接运行在JDK 1.4之上，或者继续发布能运行在1.4上的版本。JDK 1.4同样带来了很多新的技术特性，如正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器，等等。

JDK 1.4有两个后续修正版：2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的JDK 1.4.1与2003年6月26日发布的工程代号为Mantis（螳螂） 的JDK 1.4.2。 

2002年前后还发生了一件与Java没有直接关系，但事实上对Java的发展进程影响很大的事件，就是微软的.NET Framework发布。这个无论是技术实现还是目标用户上都与Java有很多相近之处的技术平台给Java带来了很多讨论、比较与竞争，.NET平台和Java平台之间声势浩大的孰优孰劣的论战到今天为止都仍然没有完全平息。

2004年9月30日，JDK 5发布，工程代号为Tiger（老虎）。Sun公司从这个版本开始放弃了谦逊 的“JDK 1.x”的命名方式，将产品版本号修改成了“JDK x”。从JDK 1.2以来，Java在语法层面上的变动一直很小，而JDK 5在Java语法易用性上做出了非常大的改进。如：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK 5中加入的。在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包等。另外，JDK 5是官方声明可以支持Windows 9x操作系统的最后一个JDK版本。 

2006年12月11日，JDK 6发布，工程代号为Mustang（野马）。在这个版本中，Sun公司终结了从 JDK 1.2开始已经有八年历史的J2EE、J2SE、J2ME的产品线命名方式，启用Java EE 6、Java SE 6、Java ME 6的新命名来代替。JDK 6的改进包括：提供初步的动态语言支持（通过内置Mozilla JavaScript Rhino引擎实现）、提供编译期注解处理器和微型HTTP服务器API，等等。同时，这个版本对Java虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的实现都有相当多的改动。

在2006年11月13日的JavaOne大会上，Sun公司宣布计划要把Java开源，在随后的一年多时间内， 它陆续地将JDK的各个部分在GPL v2（GNU General Public License v2）协议下公开了源码，并建立了 OpenJDK 组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码所有 权不属于Sun公司，Sun本身也无权进行开源处理）外，OpenJDK几乎拥有了当时SunJDK 7的全部代码，OpenJDK的质量主管曾经表示在JDK 7中，SunJDK和OpenJDK除了代码文件头的版权注释之外，代码几乎是完全一样的，所以OpenJDK 7与SunJDK 7本质上就是同一套代码库出来的产品。 JDK 6发布以后，由于代码复杂性的增加、Java开源、开发JavaFX、世界经济危机及Oracle对Sun 的收购案等原因，Sun公司在发展Java以外的事情上耗费了太多精力和资源，JDK的更新没有能够继续维持两年发布一个主版本的研发速度，这导致了JDK 6的生命周期异常的长，一共发布了211个更新升级补丁，最后的版本为Java SE 6 Update 211，于2018年10月18日发布。 

2009年2月19日，工程代号为Dolphin（海豚）的JDK 7完成了其第一个里程碑版本。按照JDK 7最初的功能规划，一共会设置十个里程碑。最后一个里程碑版本原计划定于2010年9月9日结束，但由于各种原因，JDK 7最终无法按计划完成。 从JDK 7最原始的功能清单来看，它本应是一个包含许多重要改进的JDK版本，其中规划的子项目都为Java业界翘首以盼，包括：

- Lambda项目：支持Lambda表达式，支持函数式编程。 
- Jigsaw项目：虚拟机层面的模块化支持。 
- 动态语言支持：Java是静态语言，为其他运行在Java虚拟机上的动态语言提供支持。
- Garbage-First收集器。
- Coin项目：Java语法细节进化。 

令人惋惜的是，在JDK 7开发期间，Sun公司相继在技术竞争和商业竞争中陷入泥潭，公司的股票市值跌至仅有高峰时期的3%，已无力推动JDK 7的研发工作按计划继续进行。为了尽快结束JDK 7长期跳票的问题，Oracle收购Sun公司后随即宣布马上实行“B计划”，大幅裁剪了JDK 7预定目标，以保证 JDK 7的正式版能够于2011年7月28日准时发布。“B计划”的主要措施是把不能按时完成的Lambda项目、Jigsaw项目和Coin项目的部分改进延迟到JDK 8之中。最终，JDK 7包含的改进有：提供新的G1收集器（G1在发布时依然处于Experimental状态，直至2012年4月的Update 4中才正式商用）、加强对非 Java语言的调用支持（JSR-292，这项特性在到JDK 11还有改动）、可并行的类加载架构等。

Oracle公司接手了JDK开发工作以后，迅速展现出了完全不同于Sun时期的、极具商业化的处事风格。面对Java中使用最广泛而又一直免费的Java SE产品线，Oracle很快定义了一套新的Java SE Support产品计划，把JDK的更新支持作为一项商业服务。JDK 7发布的前80个更新仍然免费面向所有用户提供，但后续的其他更新包，用户只能从“将Java SE升级到Java SE Support”与“将JDK 7升级到最新版本”两个选项里挑一个。JDK 7计划维护至2022年，迄今（面向付费用户）已发布了超过两百个更新补丁，最新版本为JDK 7 Update 221。 对于JDK 7，还有一点值得提起的是，从JDK 7 Update 4起，Java SE的核心功能正式开始为Mac OS X操作系统提供支持，并在JDK 7 Update 6中达到所有功能与Mac OS X完全兼容的程度；同时， JDK 7 Update 6还对ARM指令集架构提供了支持。至此，官方提供的JDK可以运行于Windows（不含 Windows 9x）、Linux、Solaris和Mac OS X操作系统上，支持ARM、x86、x86-64和SPARC指令集架构，JDK 7也是可以支持Windows XP操作系统的最后一个版本。

2009年4月20日，Oracle宣布正式以74亿美元的价格收购市值曾超过2000亿美元的Sun公司，传奇的Sun Microsystems从此落幕成为历史，Java商标正式划归Oracle所有（Java语言本身并不属于哪间公司所有，它由JCP组织进行管理，尽管在JCP中Sun及后来的Oracle的话语权很大）。由于此前Oracle已经收购了另外一家大型的中间件企业BEA公司，当完成对Sun公司的收购之后，Oracle分别从BEA和Sun手中取得了世界三大商用虚拟机的其中两个：JRockit和HotSpot。当时Oracle宣布要在未来一至两年的时间内，把这两个优秀的Java虚拟机合二为一。两者合并的结果只能说差强人意，JRockit的监控工具Java Mission Control被移植到了HotSpot，作为收费功能提供给购买了Java SE Advanced产品计划的用户，其他功能由于两者架构的差异性明显，HotSpot能够直接借鉴融合的功能寥寥无几。

JDK 8的第一个正式版本原定于2013年9月发布，最终还是跳票到了2014年3月18日，尽管仍然是没有赶上正点，但比起JDK 7那种以年作为计时单位、直接把公司跳崩的研发状况已是大有改善。为了保证日后JDK研发能更顺利地进行，从JDK 8开始，Oracle启用JEP（JDK Enhancement Proposals）来定义和管理纳入新版JDK发布范围的功能特性。JDK 8提供了那些曾在JDK 7中规划过，但最终未能在 JDK 7中完成的功能，主要包括：

- JEP 126：对Lambda表达式的支持，这让Java语言拥有了流畅的函数式表达能力。
- JEP 104：内置Nashorn JavaScript引擎的支持。
- JEP 150：新的时间、日期API。
- JEP 122：彻底移除HotSpot的永久代。

“B计划”中原本说好的会在JDK 8提供的Jigsaw模块化功能再次被延期到了JDK 9，不得不说，即使放到整个Java发展史里看，Jigsaw都能算是天字第一号的大坑。Java的模块化系统本身面临的技术挑战就很艰巨，从微软的DLL技术开始，到Java自己的JAR，再到.NET的Assembly，工程庞大起来都无一例外会陷入“模块地狱”的困境之中，而Jigsaw面临的更大困难是厂商之间以标准话语权为目的， 以技术为“找茬”手段的激烈竞争。

原本JDK 9是计划在2016年发布的，但在2016年伊始，Oracle就宣布JDK 9肯定要延期至2017年，后来又连续经过了两次短时间的跳票，最终到2017年9月21日才得以艰难面世。后两次跳票的原因是以 IBM和RedHat为首的十三家企业在JCP执行委员会上联手否决了Oracle提出的Jigsaw作为Java模块化规范进入JDK 9发布范围的提案。凭良心说，Java确实有模块化的刚需，不论是JDK自身（例如拆分出Java SE Embedded这样规模较小的产品）抑或是Java应用都需要用到模块化。这方面IBM本身就是各大Java发行厂商中做得最好的，它不仅让自家的JDK实现了高度模块化，还带头成立了OSGi联盟，制订了Java框架层面模块化的事实标准，所以它当然会想把OSGi推到Java规范里去争个“名份”，而不是被Jigsaw革掉“性命”。可是Oracle对此没有丝毫退让，不惜向JCP发去公开信，直言如果提案最后无法通过，那Oracle将摒弃JSR专家组，独立发展带Jigsaw的Java版本，Java顿时面临如Python 2与Python 3那般分裂的危机。不论如何，经过前后六轮投票，经历桌上桌下的斗争与妥协，Java没有分裂，JDK 9总算是带着 Jigsaw最终发布了，除了Jigsaw外，JDK 9还增强了若干工具（JS Shell、JLink、JHSDB等），整顿了 HotSpot各个模块各自为战的日志系统，支持HTTP 2客户单API等91个JEP。 JDK 9发布后，Oracle随即宣布Java将会以持续交付的形式和更加敏捷的研发节奏向前推进，以后 JDK将会在每年的3月和9月各发布一个大版本，目的就是为避免众多功能特性被集中捆绑到一个 JDK版本上而引发交付风险。这次改革确实从根源上解决了跳票问题，但也为Java的用户和发行商带来了颇大的压力，不仅程序员感慨“Java新版本还没开始用就已经过时了”，Oracle自己对着一堆JDK版本分支也在挠头，不知道该如何维护更新，该如何提供技术支持。Oracle的解决方案是顺理成章地终结掉“每个JDK版本最少维护三年”的优良传统，从此以后，每六个JDK大版本中才会被划出一个长期支持（Long Term Support，LTS）版，只有LTS版的JDK能够获得为期三年的支持和更新，普通版的 JDK就只有短短六个月的生命周期。JDK 8和JDK 11会是LTS版，再下一个就到2021年发布的JDK 17 了。 

2018年3月20日，JDK 10如期发布，这版本的主要研发目标是内部重构，诸如统一源仓库、统一垃圾收集器接口、统一即时编译器接口（JVMCI在JDK 9已经有了，这里是引入新的Graal即时编译 器）等，这些都将会是对未来Java发展大有裨益的改进，但对普通用户来说JDK 10的新特性就显得乏善可陈，毕竟它只包含了12个JEP，而且其中只有本地类型推断这一个编码端可见的改进。尽管JDK 10可见的改进有限，但2018这一年Java圈丝毫不缺乏谈资，相继发生了几件与“金钱”相关的历史性大事件。

首先是2018年3月27日，Android的Java侵权案有了最终判决，法庭裁定Google赔偿Oracle合计88亿美元，要知道2009年Oracle收购Sun也就只花了74亿，收购完成后随即就用Sun的专利把Google告上了法庭，经过Oracle法务部的几轮神操作，一场官司的赔偿让收购Sun公司等同免费。对此事Java技术圈多数吃瓜群众是站在Google这边的，认为Oracle这样做是自绝Java的发展前景，毕竟当年Android刚刚起步的时候可是Sun向Google抛去的橄榄枝，Android的流行也巩固了Java“第一编程语言”的行业地位。摒弃对企业的好恶情感，就事论事，Google采用Java的语法和API类库，开发出来的程序却不能运行在其他 Java虚拟机之上，这事情无论怎样都是有违Java技术的精神原旨的，也肯定违反了Java的使用协议。如果说Oracle控告Google“不厚道”，那当年微软用J++做了同样的事情（借用语法和API，但程序不兼容标准Java虚拟机），被Sun告到登报道歉，一边赔款一边割地，声明放弃J++语言和Windows平台上的内置虚拟机，这又该找谁说理去？按常理说Java刚给Oracle赚了88亿美金，该颇为受宠才对，可Oracle是典型只谈利益不讲情怀的公司，InfoWorld披露的一封Oracle高管邮件表明，Java体系中被认为无法盈利也没有太多战略前景的部分会逐渐被“按计划报废”（Planned Obsolescence）。这事的第一刀落下是在2018年3月，Oracle正式宣告Java EE成为历史名词。虽然Java SE、Java EE和Java ME三条产品线里确实只有Java SE称得上成功，但Java EE毕竟无比辉煌过，现在其中还持有着JDBC、JMS、Servlet等使用极为广泛的基础组件， 然而Oracle仍选择把它“扫地出门”，所有权直接赠送给Eclipse基金会，唯一的条件是以后不准再使 用“Java”这个商标，所以取而代之的将是Jakarta EE。

2018年10月，JavaOne 2018在旧金山举行，此前没有人想过这会是最后一届JavaOne大会，这个在1996年伴随着Java一同诞生、成长的开发者年度盛会，竟是Oracle下一个裁撤的对象，此外还有 Java Mission Control的开发团队，也在2018年6月被Oracle解散。

2018年9月25日，JDK 11发布，这是一个LTS版本的JDK，包含17个JEP，其中有ZGC这样的革命性的垃圾收集器出现，也有把JDK 10中的类型推断加入Lambda语法这种可见的改进，但都比不过它发布时爆出来的谣言轰动：“Java要开始收费啦！” 随着JDK 11发布，Oracle同时调整了JDK的授权许可证，里面包含了好几个动作。首先，Oracle从 JDK 11起把以前的商业特性全部开源给OpenJDK，这样OpenJDK 11和OracleJDK 11的代码和功能，在本质上就是完全相同的（官方原文是Essentially Identical）。然后，Oracle宣布以后将会同时发行两个JDK：一个是以GPLv2+CE协议下由Oracle发行的OpenJDK（本书后面章节称其为Oracle OpenJDK），另一个是在新的OTN协议下发行的传统的OracleJDK，这两个JDK共享绝大部分源码， 在功能上是几乎一样的，核心差异是前者可以免费在开发、测试或生产环境中使用，但是只有半年时间的更新支持；后者个人依然可以免费使用，但若在生产环境中商用就必须付费，可以有三年时间的更新支持。如果说由此能得出“Java要收费”的结论，那是纯属标题党，最多只能说Oracle在迫使商业用户要么不断升级JDK的版本，要么就去购买商业支持。

2019年2月，在JDK 12发布前夕，Oracle果然如之前宣布那样在六个月之后就放弃了对上一个版本 OpenJDK的维护，RedHat同时从Oracle手上接过OpenJDK 8和OpenJDK 11的管理权利和维护职责。Oracle不愿意在旧版本上继续耗费资源，而RedHat或者说它背后的IBM又乐意扩大自己在Java社区的影响力，这是一笔双赢的交易。RedHat代替Oracle成为JDK历史版本的维护者，应该有利于Java的持续稳定，但从技术发展角度来看，这并不能为Oracle领导Java社区的局面带来根本性的改变，毕竟要添加新的或实验性的功能，仅会针对Java的最新版本，而不会在旧版本上动手。

2019年3月20日，JDK 12发布，只包含8个JEP，其中主要有Switch表达式、Java微测试套件（JMH）等新功能，最引人注目的特性无疑是加入了由RedHat领导开发的Shen-andoah垃圾收集器。Shenandoah作为首个由非Oracle开发的垃圾收集器，其目标又与Oracle在JDK 11中发布的ZGC几乎完全一致，两者天生就存在竞争。Oracle马上用实际行动抵制了这个新收集器，在JDK 11发布时才说应尽 可能保证OracleJDK和OpenJDK的兼容一致，转眼就在OracleJDK 12里把Shenandoah的代码通过条件编译强行剔除掉，使其成为历史上唯一进入了OpenJDK发布清单，但在OracleJDK中无法使用的功能。 Oracle收购Sun是Java发展历史上一道明显的分界线。在Sun掌舵的前十几年里，Java获得巨大成功，同时也渐渐显露出来语言演进的缓慢与社区决策的老朽；而在Oracle主导Java后，引起竞争的同时也带来新的活力，Java发展的速度要显著高于Sun时代。Java的未来是继续向前、再攀高峰，还是由盛转衰、锋芒挫缩，你我拭目以待。 Java面临的危机挑战前所未有的艰巨，属于Java的未来也从未如此充满想象与可能。

1.4　Java虚拟机家族 12
1.4.1　虚拟机始祖：Sun Classic/Exact VM 12
1.4.2　武林盟主：HotSpot VM 13
1.4.3　小家碧玉：Mobile/Embedded VM 14
1.4.4　天下第二：BEA JRockit/IBM J9 VM 15
1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16
1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17
1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18
1.4.8　百家争鸣 19
1.5　展望Java技术的未来 21
1.5.1　无语言倾向 21
1.5.2　新一代即时编译器 23
1.5.3　向Native迈进 24
1.5.4　灵活的胖子 26
1.5.5　语言语法持续增强 27
1.6　实战：自己编译JDK 29
1.6.1　获取源码 29
1.6.2　系统需求 31
1.6.3　构建编译环境 33
1.6.4　进行编译 34
1.6.5　在IDE工具中进行源码调试 36
1.7　本章小结 39
第二部分　自动内存管理
第2章　Java内存区域与内存溢出异常 42
2.1　概述 42
2.2　运行时数据区域 42
2.2.1　程序计数器 43
2.2.2　Java虚拟机栈 43
2.2.3　本地方法栈 44
2.2.4　Java堆 44
2.2.5　方法区 46
2.2.6　运行时常量池 47
2.2.7　直接内存 47
2.3　HotSpot虚拟机对象探秘 48
2.3.1　对象的创建 48
2.3.2　对象的内存布局 51
2.3.3　对象的访问定位 52
2.4　实战：OutOfMemoryError异常 53
2.4.1　Java堆溢出 54
2.4.2　虚拟机栈和本地方法栈溢出 56
2.4.3　方法区和运行时常量池溢出 61
2.4.4　本机直接内存溢出 65
2.5　本章小结 66
第3章　垃圾收集器与内存分配策略 67
3.1　概述 67
3.2　对象已死？ 68
3.2.1　引用计数算法 68
3.2.2　可达性分析算法 70
3.2.3　再谈引用 71
3.2.4　生存还是死亡？ 72
3.2.5　回收方法区 74
3.3　垃圾收集算法 75
3.3.1　分代收集理论 75
3.3.2　标记-清除算法 77
3.3.3　标记-复制算法 78
3.3.4　标记-整理算法 79
3.4　HotSpot的算法细节实现 81
3.4.1　根节点枚举 81
3.4.2　安全点 82
3.4.3　安全区域 83
3.4.4　记忆集与卡表 84
3.4.5　写屏障 85
3.4.6　并发的可达性分析 87
3.5　经典垃圾收集器 89
3.5.1　Serial收集器 90
3.5.2　ParNew收集器 92
3.5.3　Parallel Scavenge收集器 93
3.5.4　Serial Old收集器 94
3.5.5　Parallel Old收集器 95
3.5.6　CMS收集器 96
3.5.7　Garbage First收集器 98
3.6　低延迟垃圾收集器 104
3.6.1　Shenandoah收集器 105
3.6.2　ZGC收集器 112
3.7　选择合适的垃圾收集器 121
3.7.1　Epsilon收集器 121
3.7.2　收集器的权衡 121
3.7.3　虚拟机及垃圾收集器日志 122
3.7.4　垃圾收集器参数总结 127
3.8　实战：内存分配与回收策略 129
3.8.1　对象优先在Eden分配 130
3.8.2　大对象直接进入老年代 131
3.8.3　长期存活的对象将进入老年代 132
3.8.4　动态对象年龄判定 134
3.8.5　空间分配担保 135
3.9　本章小结 137
第4章　虚拟机性能监控、故障处理工具 138
4.1　概述 138
4.2　基础故障处理工具 138
4.2.1　jps：虚拟机进程状况工具 141
4.2.2　jstat：虚拟机统计信息监视工具 142
4.2.3　jinfo：Java配置信息工具 143
4.2.4　jmap：Java内存映像工具 144
4.2.5　jhat：虚拟机堆转储快照分析工具 145
4.2.6　jstack：Java堆栈跟踪工具 146
4.2.7　基础工具总结 148
4.3　可视化故障处理工具 151
4.3.1　JHSDB：基于服务性代理的调试工具 152
4.3.2　JConsole：Java监视与管理控制台 157
4.3.3　VisualVM：多合-故障处理工具 164
4.3.4　Java Mission Control：可持续在线的监控工具 171
4.4　HotSpot虚拟机插件及工具 175
4.5　本章小结 180
第5章　调优案例分析与实战 181
5.1　概述 181
5.2　案例分析 181
5.2.1　大内存硬件上的程序部署策略 182
5.2.2　集群间同步导致的内存溢出 184
5.2.3　堆外内存导致的溢出错误 185
5.2.4　外部命令导致系统缓慢 187
5.2.5　服务器虚拟机进程崩溃 187
5.2.6　不恰当数据结构导致内存占用过大 188
5.2.7　由Windows虚拟内存导致的长时间停顿 189
5.2.8　由安全点导致长时间停顿 190
5.3　实战：Eclipse运行速度调优 192
5.3.1　调优前的程序运行状态 193
5.3.2　升级JDK版本的性能变化及兼容问题 196
5.3.3　编译时间和类加载时间的优化 200
5.3.4　调整内存设置控制垃圾收集频率 203
5.3.5　选择收集器降低延迟 206
5.4　本章小结 209
第三部分　虚拟机执行子系统
第6章　类文件结构 212
6.1　概述 212
6.2　无关性的基石 212
6.3　Class类文件的结构 214
6.3.1　魔数与Class文件的版本 215
6.3.2　常量池 218
6.3.3　访问标志 224
6.3.4　类索引、父类索引与接口索引集合 225
6.3.5　字段表集合 226
6.3.6　方法表集合 229
6.3.7　属性表集合 230
6.4　字节码指令简介 251
6.4.1　字节码与数据类型 251
6.4.2　加载和存储指令 253
6.4.3　运算指令 254
6.4.4　类型转换指令 255
6.4.5　对象创建与访问指令 256
6.4.6　操作数栈管理指令 256
6.4.7　控制转移指令 257
6.4.8　方法调用和返回指令 257
6.4.9　异常处理指令 258
6.4.10　同步指令 258
6.5　公有设计，私有实现 259
6.6　Class文件结构的发展 260
6.7　本章小结 261
第7章　虚拟机类加载机制 262
7.1　概述 262
7.2　类加载的时机 263
7.3　类加载的过程 267
7.3.1　加载 267
7.3.2　验证 268
7.3.3　准备 271
7.3.4　解析 272
7.3.5　初始化 277
7.4　类加载器 279
7.4.1　类与类加载器 280
7.4.2　双亲委派模型 281
7.4.3　破坏双亲委派模型 285
7.5　Java模块化系统 287
7.5.1　模块的兼容性 288
7.5.2　模块化下的类加载器 290
7.6　本章小结 292
第8章　虚拟机字节码执行引擎 293
8.1　概述 293
8.2　运行时栈帧结构 294
8.2.1　局部变量表 294
8.2.2　操作数栈 299
8.2.3　动态连接 300
8.2.4　方法返回地址 300
8.2.5　附加信息 301
8.3　方法调用 301
8.3.1　解析 301
8.3.2　分派 303
8.4　动态类型语言支持 315
8.4.1　动态类型语言 316
8.4.2　Java与动态类型 317
8.4.3　java.lang.invoke包 318
8.4.4　invokedynamic指令 321
8.4.5　实战：掌控方法分派规则 324
8.5　基于栈的字节码解释执行引擎 326
8.5.1　解释执行 327
8.5.2　基于栈的指令集与基于寄存器的指令集 328
8.5.3　基于栈的解释器执行过程 329
8.6　本章小结 334
第9章　类加载及执行子系统的案例与实战 335
9.1　概述 335
9.2　案例分析 335
9.2.1　Tomcat：正统的类加载器架构 335
9.2.2　OSGi：灵活的类加载器架构 338
9.2.3　字节码生成技术与动态代理的实现 341
9.2.4　Backport工具：Java的时光机器 345
9.3　实战：自己动手实现远程执行功能 348
9.3.1　目标 348
9.3.2　思路 349
9.3.3　实现 350
9.3.4　验证 355
9.4　本章小结 356
第四部分　程序编译与代码优化
第10章　前端编译与优化 358
10.1　概述 358
10.2　Javac编译器 359
10.2.1　Javac的源码与调试 359
10.2.2　解析与填充符号表 362
10.2.3　注解处理器 363
10.2.4　语义分析与字节码生成 364
10.3　Java语法糖的味道 367
10.3.1　泛型 367
10.3.2　自动装箱、拆箱与遍历循环 375
10.3.3　条件编译 377
10.4　实战：插入式注解处理器 378
10.4.1　实战目标 379
10.4.2　代码实现 379
10.4.3　运行与测试 385
10.4.4　其他应用案例 386
10.5　本章小结 386
第11章　后端编译与优化 388
11.1　概述 388
11.2　即时编译器 389
11.2.1　解释器与编译器 389
11.2.2　编译对象与触发条件 392
11.2.3　编译过程 397
11.2.4　实战：查看及分析即时编译结果 398
11.3　提前编译器 404
11.3.1　提前编译的优劣得失 405
11.3.2　实战：Jaotc的提前编译 408
11.4　编译器优化技术 411
11.4.1　优化技术概览 411
11.4.2　方法内联 415
11.4.3　逃逸分析 417
11.4.4　公共子表达式消除 420
11.4.5　数组边界检查消除 421
11.5　实战：深入理解Graal编译器 423
11.5.1　历史背景 423
11.5.2　构建编译调试环境 424
11.5.3　JVMCI编译器接口 426
11.5.4　代码中间表示 429
11.5.5　代码优化与生成 432
11.6　本章小结 436
第五部分　高效并发
第12章　Java内存模型与线程 438
12.1　概述 438
12.2　硬件的效率与一致性 439
12.3　Java内存模型 440
12.3.1　主内存与工作内存 441
12.3.2　内存间交互操作 442
12.3.3　对于volatile型变量的特殊规则 444
12.3.4　针对long和double型变量的特殊规则 450
12.3.5　原子性、可见性与有序性 450
12.3.6　先行发生原则 452
12.4　Java与线程 455
12.4.1　线程的实现 455
12.4.2　Java线程调度 458
12.4.3　状态转换 460
12.5　Java与协程 461
12.5.1　内核线程的局限 461
12.5.2　协程的复苏 462
12.5.3　Java的解决方案 464
12.6　本章小结 465
第13章　线程安全与锁优化 466
13.1　概述 466
13.2　线程安全 466
13.2.1　Java语言中的线程安全 467
13.2.2　线程安全的实现方法 471
13.3　锁优化 479
13.3.1　自旋锁与自适应自旋 479
13.3.2　锁消除 480
13.3.3　锁粗化 481
13.3.4　轻量级锁 481
13.3.5　偏向锁 483
13.4　本章小结 485
附录A　在Windows系统下编译OpenJDK 6 486
附录B　展望Java技术的未来（2013年版） 493
附录C　虚拟机字节码指令表 499
附录D　对象查询语言（OQL）简介 506
附录E　JDK历史版本轨迹 512
